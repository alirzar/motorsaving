'''UMAP representation of connectivity matrices before and after Riemannian centering.'''
import re
from pathlib import Path
from typing import Iterable, List, Tuple, Union

import matplotlib.pyplot as plt
import matplotlib.patches as mpatches
import numpy as np
import pandas as pd
import seaborn as sns
from tqdm import tqdm
from umap import UMAP

from saveman.analyses import plotting
from saveman.config import Config
from saveman.utils import get_files

# Set plotting settings (fonts, spines, etc.) using project defaults.
plotting.set_plotting()

# Create figure output directory.
FIG_DIR = Path(Config().figures) / "centering_umap"
FIG_DIR.mkdir(parents=True, exist_ok=True)

# Fixed colors for tasks (kept stable across runs for consistency in figure revisions).
TASK_COLORS = ["Red", "Blue", "Green", "Yellow", "Orange", "Purple", "Pink", "Brown", "Grey", "Black"]


def _parse_labels_from_column_name(name: str) -> Tuple[str, str]:
    """Parse (subject, task_label) from a flattened-matrix column name.

    The upstream naming convention in this project is not strictly standardized across datasets.
    We therefore parse conservatively:
      - subject: first token that looks like 'sub-XXXX' or the first underscore-separated token
      - task_label: second underscore-separated token if present, otherwise 'unknown'

    Parameters
    ----------
    name:
        Column name generated by _read_and_flatten().

    Returns
    -------
    (subject, task_label)
    """
    tokens = name.split("_")
    # Prefer an explicit BIDS-like subject token if present.
    for tok in tokens:
        if re.match(r"^sub-[A-Za-z0-9]+$", tok):
            subject = tok
            break
    else:
        subject = tokens[0] if tokens else "unknown"

    task_label = tokens[1] if len(tokens) > 1 else "unknown"
    return subject, task_label


def _read_and_flatten(file_list: Iterable[Union[str, Path]]) -> pd.DataFrame:
    """Read a list of TSV connectivity matrices, flatten, and concatenate into a DataFrame.

    Each input TSV is expected to be a square matrix with an index column and header row.
    The output DataFrame has one column per matrix and rows corresponding to flattened entries.

    Parameters
    ----------
    file_list:
        Iterable of paths to TSV files.

    Returns
    -------
    pd.DataFrame
        Columns correspond to individual matrices; rows to flattened matrix entries.
    """
    data_frames: List[pd.DataFrame] = []

    for filepath in tqdm(list(file_list), desc="Reading connectivity matrices"):
        fp = Path(filepath)
        basename = fp.stem.split("_")

        fp_str = str(fp)
        if "washout" in fp_str:
            # Example: sub-01_task-washout-ses-XX_cmat.tsv -> sub-01_task-washout-XX
            name = f"{basename[0]}_{basename[1]}-washout-{basename[-1].replace('cmat', '')}"
        else:
            name = f"{basename[0]}_{basename[1]}-{basename[-1].replace('cmat', '')}"

        df = pd.read_table(fp, index_col=0)
        flattened = df.values.flatten()
        data_frames.append(pd.DataFrame(flattened, columns=[name]))

    if not data_frames:
        raise ValueError("No connectivity matrices were read; check file_list and TSV format.")

    return pd.concat(data_frames, axis=1)


def cmat_umap(
    dataset_dir: Union[str, Path],
    random_state: int = 42,
    n_neighbors: int = 15,
    min_dist: float = 0.1,
) -> Tuple[np.ndarray, np.ndarray, np.ndarray, pd.Index]:
    """Compute a 2D UMAP embedding from flattened connectivity matrices.

    Parameters
    ----------
    dataset_dir:
        Directory containing TSV matrices (recursively searched with '*/*.tsv').
    random_state:
        Seed for UMAP stochastic optimization (set for deterministic embeddings).
    n_neighbors:
        UMAP local neighborhood size.
    min_dist:
        UMAP minimum distance parameter.

    Returns
    -------
    embedding:
        (n_matrices, 2) array of UMAP coordinates.
    subject_ids:
        Integer codes for subject labels (for coloring).
    task_ids:
        Integer codes for task labels (for coloring).
    task_labels:
        Task labels aligned with rows of `embedding`.
    """
    cmats = get_files([str(dataset_dir), "*/*.tsv"])
    if not cmats:
        raise FileNotFoundError(f"No .tsv files found in {dataset_dir}")

    flat_cmats = _read_and_flatten(cmats)

    # Parse subject/task labels from the per-matrix column names.
    parsed = [_parse_labels_from_column_name(c) for c in flat_cmats.columns]
    subject_labels = pd.Index([p[0] for p in parsed])
    task_labels = pd.Index([p[1] for p in parsed])

    subject_ids = pd.factorize(subject_labels)[0]

    # Keep task ID mapping stable and aligned with label order of appearance (not np.unique sorting).
    unique_tasks = pd.Index(pd.unique(task_labels))
    task_ids = pd.Categorical(task_labels, categories=unique_tasks, ordered=True).codes

    reducer = UMAP(random_state=random_state, n_neighbors=n_neighbors, min_dist=min_dist)
    embedding = reducer.fit_transform(flat_cmats.T)

    return embedding, subject_ids, task_ids, task_labels


def plot_umap(
    embedding: np.ndarray,
    subject_ids: np.ndarray,
    task_ids: np.ndarray,
    task_labels: pd.Index,
    title_suffix: str,
    save_path: Union[str, Path],
) -> None:
    """Plot UMAP embeddings colored by subjects and tasks.

    Produces a two-panel figure:
      - left: colored by subject
      - right: colored by task/session label

    Parameters
    ----------
    embedding, subject_ids, task_ids, task_labels:
        Outputs from cmat_umap().
    title_suffix:
        Label appended to subplot titles (e.g., 'Before Centering').
    save_path:
        Output file path. If no suffix is provided, '' is added.
    """
    save_path = Path(save_path)
    if save_path.suffix == "":
        save_path = save_path.with_suffix("")

    cmap = plt.get_cmap("tab20")
    unique_tasks = pd.Index(pd.unique(task_labels))

    # Marker heuristic: if session info is embedded in the label.
    marker_map = {label: ("o" if "ses-01" in str(label) else "s") for label in unique_tasks}

    fig, axs = plt.subplots(1, 2, figsize=(10, 5))

    # Plot by subject
    axs[0].scatter(embedding[:, 0], embedding[:, 1], c=subject_ids, cmap=cmap)
    axs[0].set_xlabel("Dimension 1", fontsize=12, fontweight="bold")
    axs[0].set_ylabel("Dimension 2", fontsize=12, fontweight="bold")
    axs[0].set_title(f"Subjects ({title_suffix})", fontsize=16)

    # Plot by task (stable mapping)
    for i, label in enumerate(unique_tasks):
        color = TASK_COLORS[i % len(TASK_COLORS)]
        axs[1].scatter(
            embedding[task_ids == i, 0],
            embedding[task_ids == i, 1],
            color=color,
            marker=marker_map[label],
            label=str(label).capitalize(),
        )

    axs[1].set_xlabel("Dimension 1", fontsize=12, fontweight="bold")
    axs[1].set_title(f"Tasks ({title_suffix})", fontsize=16)

    sns.despine()
    plt.tight_layout()
    fig.savefig(save_path, dpi=300)
    plt.show()


def plot_legend(labels: Iterable[str], colors: List[str], save_path: Union[str, Path]) -> None:
    """Plot and save a legend separately (useful for assembling multi-panel figures)."""
    save_path = Path(save_path)
    if save_path.suffix == "":
        save_path = save_path.with_suffix("")

    labels = list(labels)
    patches = [
        mpatches.Patch(color=colors[i % len(colors)], label=str(labels[i]).capitalize())
        for i in range(len(labels))
    ]
    fig, ax = plt.subplots(figsize=(4, 4))
    ax.legend(handles=patches, fontsize=12, ncol=1, edgecolor="gray")
    ax.axis("off")
    fig.savefig(save_path, dpi=300)
    plt.show()


def main() -> None:
    config = Config()

    embedding_before, subject_ids, task_ids, task_labels = cmat_umap(config.connect)
    plot_umap(
        embedding_before,
        subject_ids,
        task_ids,
        task_labels,
        title_suffix="Before Centering",
        save_path=FIG_DIR / "umap_before_centering",
    )

    embedding_after, subject_ids, task_ids, task_labels = cmat_umap(config.connect_centered)
    plot_umap(
        embedding_after,
        subject_ids,
        task_ids,
        task_labels,
        title_suffix="After Centering",
        save_path=FIG_DIR / "umap_after_centering",
    )

    unique_labels = pd.Index(pd.unique(task_labels))
    plot_legend(unique_labels, TASK_COLORS, save_path=FIG_DIR / "umap_legend")